//! Index generation for documentation categories

use crate::{
    error::{Result, XzeError},
    types::DiátaxisCategory,
};
use std::{collections::HashMap, path::PathBuf};
use tracing::info;

use super::Document;

/// Index generator for creating category indexes
pub struct IndexGenerator {
    output_dir: PathBuf,
}

impl IndexGenerator {
    /// Create a new index generator
    pub fn new(output_dir: PathBuf) -> Self {
        Self { output_dir }
    }

    /// Generate main documentation index
    pub async fn generate_main_index(&self, documents: &[Document]) -> Result<PathBuf> {
        let index_path = self.output_dir.join("README.md");

        let mut content = String::from("# Documentation\n\n");
        content.push_str(
            "This documentation follows the Diátaxis framework, organizing content \
            into four categories based on your needs:\n\n",
        );

        // Group by category
        let mut by_category: HashMap<DiátaxisCategory, Vec<&Document>> = HashMap::new();
        for doc in documents {
            by_category
                .entry(doc.category.clone())
                .or_insert_with(Vec::new)
                .push(doc);
        }

        // Generate sections for each category
        for category in [
            DiátaxisCategory::Tutorial,
            DiátaxisCategory::HowTo,
            DiátaxisCategory::Reference,
            DiátaxisCategory::Explanation,
        ] {
            content.push_str(&format!("## {}\n\n", category));

            let description = self.get_category_description(&category);
            content.push_str(&format!("**{}**\n\n", description));

            if let Some(docs) = by_category.get(&category) {
                for doc in docs {
                    let relative_path = self.make_relative_path(&doc.file_path)?;
                    content.push_str(&format!("- [{}]({})\n", doc.title, relative_path));
                }
            } else {
                content.push_str("*No documents available yet*\n");
            }

            content.push_str("\n");
        }

        content.push_str("---\n\n*This documentation was automatically generated by XZe.*\n");

        // Write main index
        tokio::fs::write(&index_path, content)
            .await
            .map_err(|e| XzeError::filesystem(format!("Failed to write main index: {}", e)))?;

        info!("Generated main documentation index at {:?}", index_path);
        Ok(index_path)
    }

    /// Generate index file for a category
    pub async fn generate_category_index(
        &self,
        category: &DiátaxisCategory,
        documents: &[Document],
    ) -> Result<PathBuf> {
        let category_dir = self.get_category_dir(category);
        let index_path = self.output_dir.join(category_dir).join("README.md");

        // Create parent directories
        if let Some(parent) = index_path.parent() {
            tokio::fs::create_dir_all(parent)
                .await
                .map_err(|e| XzeError::filesystem(format!("Failed to create directory: {}", e)))?;
        }

        // Filter documents for this category
        let category_docs: Vec<&Document> = documents
            .iter()
            .filter(|d| d.category == *category)
            .collect();

        // Generate index content
        let mut content = format!("# {}\n\n", category.to_string());

        content.push_str(&self.get_category_description(category));
        content.push_str("\n\n## What is this?\n\n");
        content.push_str(&self.get_category_explanation(category));
        content.push_str("\n\n## Documents\n\n");

        if category_docs.is_empty() {
            content.push_str("No documents available yet.\n");
        } else {
            for doc in category_docs {
                let filename = doc
                    .file_path
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("");

                // Add description if available
                if let Some(description) = doc.metadata.custom.get("description") {
                    content.push_str(&format!(
                        "- [{}]({}) - {}\n",
                        doc.title, filename, description
                    ));
                } else {
                    content.push_str(&format!("- [{}]({})\n", doc.title, filename));
                }
            }
        }

        content.push_str("\n## Related Categories\n\n");
        content.push_str(&self.get_related_links(category));
        content.push('\n');

        // Write index file
        tokio::fs::write(&index_path, content)
            .await
            .map_err(|e| XzeError::filesystem(format!("Failed to write index: {}", e)))?;

        info!("Generated index for {:?} at {:?}", category, index_path);
        Ok(index_path)
    }

    /// Generate all index files
    pub async fn generate_all_indexes(&self, documents: &[Document]) -> Result<Vec<PathBuf>> {
        let mut index_paths = Vec::new();

        // Generate main index
        match self.generate_main_index(documents).await {
            Ok(path) => index_paths.push(path),
            Err(e) => tracing::warn!("Failed to generate main index: {}", e),
        }

        // Generate category indexes
        for category in [
            DiátaxisCategory::Tutorial,
            DiátaxisCategory::HowTo,
            DiátaxisCategory::Reference,
            DiátaxisCategory::Explanation,
        ] {
            match self.generate_category_index(&category, documents).await {
                Ok(path) => index_paths.push(path),
                Err(e) => tracing::warn!("Failed to generate index for {:?}: {}", category, e),
            }
        }

        Ok(index_paths)
    }

    /// Generate table of contents for document
    pub fn generate_toc(&self, content: &str) -> String {
        let mut toc = String::from("## Table of Contents\n\n");
        let mut in_code_block = false;

        for line in content.lines() {
            // Track code blocks to avoid headers inside them
            if line.trim().starts_with("```") {
                in_code_block = !in_code_block;
                continue;
            }

            if in_code_block {
                continue;
            }

            // Process markdown headers
            if let Some(header) = line.trim().strip_prefix('#') {
                let level = header.chars().take_while(|c| *c == '#').count() + 1;
                let title = header.trim_start_matches('#').trim();

                if level > 1 && level <= 4 {
                    // Skip the main title (level 1)
                    let indent = "  ".repeat(level - 2);
                    let anchor = title
                        .to_lowercase()
                        .replace(char::is_whitespace, "-")
                        .chars()
                        .filter(|c| c.is_alphanumeric() || *c == '-')
                        .collect::<String>();

                    toc.push_str(&format!("{}- [{}](#{})\n", indent, title, anchor));
                }
            }
        }

        toc.push('\n');
        toc
    }

    /// Insert TOC into content after first header
    pub fn insert_toc(&self, content: &str) -> String {
        let toc = self.generate_toc(content);
        let lines: Vec<&str> = content.lines().collect();

        // Find the first header
        let mut insert_pos = 0;
        for (i, line) in lines.iter().enumerate() {
            if line.trim().starts_with('#') {
                insert_pos = i + 1;
                break;
            }
        }

        // Skip any empty lines after the header
        while insert_pos < lines.len() && lines[insert_pos].trim().is_empty() {
            insert_pos += 1;
        }

        // Insert TOC
        let mut result = String::new();
        for (i, line) in lines.iter().enumerate() {
            result.push_str(line);
            result.push('\n');

            if i == insert_pos - 1 {
                result.push('\n');
                result.push_str(&toc);
            }
        }

        result
    }

    /// Get category directory name
    fn get_category_dir(&self, category: &DiátaxisCategory) -> &str {
        match category {
            DiátaxisCategory::Tutorial => "tutorials",
            DiátaxisCategory::HowTo => "how_to",
            DiátaxisCategory::Reference => "reference",
            DiátaxisCategory::Explanation => "explanations",
        }
    }

    /// Get short description for a category
    fn get_category_description(&self, category: &DiátaxisCategory) -> &str {
        match category {
            DiátaxisCategory::Tutorial => {
                "Learning-oriented: Step-by-step lessons to learn new concepts"
            }
            DiátaxisCategory::HowTo => {
                "Goal-oriented: Practical guides to solve specific problems"
            }
            DiátaxisCategory::Reference => {
                "Information-oriented: Technical specifications and API details"
            }
            DiátaxisCategory::Explanation => {
                "Understanding-oriented: Background and conceptual discussion"
            }
        }
    }

    /// Get detailed explanation for a category
    fn get_category_explanation(&self, category: &DiátaxisCategory) -> &str {
        match category {
            DiátaxisCategory::Tutorial => {
                "Tutorials are learning-oriented lessons that guide you through \
                learning a specific topic step by step. They are designed to help \
                you get started and build confidence through hands-on practice."
            }
            DiátaxisCategory::HowTo => {
                "How-to guides are goal-oriented recipes that help you solve \
                specific problems and accomplish tasks. They assume you have some \
                background knowledge and focus on practical solutions."
            }
            DiátaxisCategory::Reference => {
                "Reference documentation provides technical descriptions of the \
                system, its APIs, and components. It is information-oriented and \
                designed for quick lookup and detailed specifications."
            }
            DiátaxisCategory::Explanation => {
                "Explanations are understanding-oriented discussions that clarify \
                and illuminate particular topics. They provide context, background, \
                and deeper insight into design decisions and concepts."
            }
        }
    }

    /// Get links to related categories
    fn get_related_links(&self, category: &DiátaxisCategory) -> String {
        let mut links = String::new();

        match category {
            DiátaxisCategory::Tutorial => {
                links.push_str("- [How-To Guides](../how_to/) - Apply what you learned\n");
                links.push_str("- [Reference](../reference/) - Look up API details\n");
                links.push_str("- [Explanations](../explanations/) - Understand concepts\n");
            }
            DiátaxisCategory::HowTo => {
                links.push_str("- [Tutorials](../tutorials/) - Learn the basics\n");
                links.push_str("- [Reference](../reference/) - Technical specifications\n");
                links.push_str("- [Explanations](../explanations/) - Background information\n");
            }
            DiátaxisCategory::Reference => {
                links.push_str("- [Tutorials](../tutorials/) - Learn by doing\n");
                links.push_str("- [How-To Guides](../how_to/) - Practical tasks\n");
                links.push_str("- [Explanations](../explanations/) - Deep dive\n");
            }
            DiátaxisCategory::Explanation => {
                links.push_str("- [Tutorials](../tutorials/) - Hands-on learning\n");
                links.push_str("- [How-To Guides](../how_to/) - Practical solutions\n");
                links.push_str("- [Reference](../reference/) - Technical details\n");
            }
        }

        links
    }

    /// Make path relative to output directory
    fn make_relative_path(&self, path: &PathBuf) -> Result<String> {
        path.strip_prefix(&self.output_dir)
            .map(|p| p.to_string_lossy().to_string())
            .or_else(|_| Ok(path.to_string_lossy().to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::DiátaxisCategory;

    #[test]
    fn test_index_generator_creation() {
        let generator = IndexGenerator::new(PathBuf::from("docs"));
        assert_eq!(generator.output_dir, PathBuf::from("docs"));
    }

    #[test]
    fn test_toc_generation() {
        let generator = IndexGenerator::new(PathBuf::from("docs"));
        let content = r#"# Title

## Section 1

Content here.

## Section 2

### Subsection

More content.
"#;

        let toc = generator.generate_toc(content);
        assert!(toc.contains("Section 1"));
        assert!(toc.contains("Section 2"));
        assert!(toc.contains("Subsection"));
    }

    #[test]
    fn test_toc_skips_code_blocks() {
        let generator = IndexGenerator::new(PathBuf::from("docs"));
        let content = r#"# Title

## Real Section

```rust
// This is a comment with # symbols
// ## These should be ignored
```

## Another Section
"#;

        let toc = generator.generate_toc(content);
        assert!(toc.contains("Real Section"));
        assert!(toc.contains("Another Section"));
        assert!(!toc.contains("These should be ignored"));
    }

    #[test]
    fn test_category_descriptions() {
        let generator = IndexGenerator::new(PathBuf::from("docs"));

        let tutorial_desc = generator.get_category_description(&DiátaxisCategory::Tutorial);
        assert!(tutorial_desc.contains("Learning-oriented"));

        let howto_desc = generator.get_category_description(&DiátaxisCategory::HowTo);
        assert!(howto_desc.contains("Goal-oriented"));

        let reference_desc = generator.get_category_description(&DiátaxisCategory::Reference);
        assert!(reference_desc.contains("Information-oriented"));

        let explanation_desc = generator.get_category_description(&DiátaxisCategory::Explanation);
        assert!(explanation_desc.contains("Understanding-oriented"));
    }

    #[test]
    fn test_category_dir_names() {
        let generator = IndexGenerator::new(PathBuf::from("docs"));

        assert_eq!(
            generator.get_category_dir(&DiátaxisCategory::Tutorial),
            "tutorials"
        );
        assert_eq!(
            generator.get_category_dir(&DiátaxisCategory::HowTo),
            "how_to"
        );
        assert_eq!(
            generator.get_category_dir(&DiátaxisCategory::Reference),
            "reference"
        );
        assert_eq!(
            generator.get_category_dir(&DiátaxisCategory::Explanation),
            "explanations"
        );
    }
}
